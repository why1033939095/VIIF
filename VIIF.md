# 获取图片
1. 使用PIL.Image模块中的open函数，读取RGB图像（红外＋可见光）
# 预处理图片
1. 将RGB图转化成灰度图
2. 将灰度图的灰度值范围拉伸到0-255
3. 调整图片大小，利用cv2.resize将可见光的灰度图调整到红外图像的大小
# 匹配
1. 角点检测
    1. 采用cv2的Canny边缘检测算法，获取图片的边缘点
    2. 提取边缘
        1. 初步提取边缘
            > 1. 任选一个检测出的边缘点，并将其灰度值归零，将横纵坐标存入该点所在的边缘对应的数组中
            > 2. 以其为中心，判断周围8个点中是否有检测出的边缘点
            > 3. 若有边缘点，则将离中心点最近的边缘点存入数组中，并将中心点坐标更新为该边缘点
            > 4. 返回步骤1，直到所有边缘点的灰度值全部为0
        2. 点集数组中边缘点的个数大于（图像长+宽）/60，那么将其算作一条轮廓
        3. 轮廓集合用一个列表curve来表示
        4. 获取每条轮廓的起点和终点的横纵坐标，分别以两个nx2数组存放在一起
        5. 通过起始点和终点的距离，判断该轮廓是环还是线，将判断结果存放在一个列表中
    3. 提取轮廓角
        1. 判断边缘的类型
            * 若为环，则在边缘x和y坐标，前面添加W（高斯分布的宽度/2）个坐标（x，y的后W个），后面添加W个坐标（x，y的前W个）
            * 若为线，则在边缘x和y坐标，前面添加W个坐标（0-(w到1)），后面添加W个坐标（最后一个点-（倒数第二个点到倒数第W+1个点））
        2. 对x坐标数组和y坐标数组分别进行**高斯卷积**，取高2W+L次系数
        3. 对x和y得到的卷积结果分别进行一阶差分和二阶差分。
        4. 利用公式：$\frac{X_u\times{Y_{uu}}-X_{uu}\times{Y_u}}{{(X_u\times{X_u}+Y_u\times{Y_u})}^{1.5}}$
            求出轮廓的曲率，以集合K存储
        5. 找出曲率上的极大值点和极小值点，并以集合extremum存储极值点在K中的坐标
        6. 找出极值点两侧曲率最小的点作为两个辅助点，其序号连同极值点存储在数组lambda_LR中
        7. 将极值点在该段轮廓中的位置以及经过高斯卷积后的结果计算其轮廓角，将一段弧均分成多段，根据端点坐标计算出圆心的坐标，其中点与圆心的连线就是角平分线，计算出其角平分线和端点与中点连线的夹角。最后剔除掉角度在170-190之间的极值点。
        8. 对极值点周围的x坐标和y坐标进行高斯加权，求和，减去极值点的坐标并除以其范数，以此坐标求出一个角度作为其最终的角度。
        9. 对轮廓起始点以及终点做出上述同样的操作，即对起始点和终点附近的点坐标进行高斯加权求和，减去起始点和终点的坐标后除以其范数，得到角度值，作为辅助角。
2. 对可见光图和红外图同时进行角点提取以及轮廓角计算
3. 描述子获取
    1. 对灰度图使用不同的滤波函数进行滤波处理。并进行并根据公式$gradient_x = 1.414*gradient_u + gradient_{uv} - gradient_{vu}$和$gradient_y = 1.414*gradient_v + gradient_{uv} + gradient_{vu}$计算其x，y的梯度值，再平方和后开根得到其最大的方向导数。
    2. 通过梯度值计算出其梯度方向并存储。
    3. 裁出一个矩形区域，对方向导数进行排序，然后每$\frac{1}{5}$取出一个值作为阈值
    4. 对每个方向导数根据阈值进行权值计算，对原矩阵进行替换
    5. 求出轮廓角的正余弦，并对其进行加权处理
    6. 利用梯度角，轮廓角得到权重。并累加求和
4. 对可见光图片按一定比例进行缩放，对缩放之后的图片进行描述子的提取，将对应的特征向量提取出来之后，以特征向量个数*4*4*8特征向量的形式进行表示。
5. 特征点匹配  
    将红外图片的每个特征向量分别和可见光图片的描述子进行点乘运算，然后对运算结果取反余弦并进行排序（我觉得应该是为了将其离散化，数值跨度更大，乘积结果小的赋予一个大的权值），当第二个值*0.97大于第一个值，记录并匹配，红外图片匹配上的点，记录红外图每个特征向量对应于不同比例的可见光图像最小的反余弦值，记录下其对应点在排序之后的结果的序号，符合条件的红外图像第i个特征向量，可见光图像的j个比例，将序号存放于match1[i][j]中。求出描述子之积的反余弦的最小缩放比例mintheta与序号。然后更新在不同缩放比例满足要求的最小反余弦的特征向量的个数。  
    对可见光图的每个特征向量分别与红外图像的特征向量点乘，重复上述操作，得到可见光图像对应的矩阵和参数。  
    match1中存放的是红外图像每个特征向量对应的特征点匹配上的可见光图像上的特征点序号，match2中存放的是可见光图像每个特征向量对应的特征点匹配上的红外图像上的特征点序号。
    所以match2[match1[i]]=i才算匹配上特征点。  
    然后比较出匹配上最多的特征点的缩放比例。
    计算匹配上的特征点对应的轮廓角的差，并将其离散直方化，插值，对结果进行排序，得到其众数，作为旋转角，进行旋转。  
    旋转之后，将匹配上的特征点连线，等长平行，那么则认为匹配是正确的，否则将其移除掉。
    再针对这个倾斜角进行处理，通过一系列操作，再对值进行删减。通过RANSAC算法，随机取样，进行仿射变换，得到正确的匹配点。
    然后根据匹配点，进行亚像素级的匹配得到处理后的可见光图像，然后再进行投影变换，将红外图像向可见光图像上投影。
    最后进行图像裁剪重合。


# 程序问题
1. py_graymosaic中utu和vtv直接读取数据

        
